## Object Oriented Programming

객체 지향 프로그래밍 이전 프로그래밍 패러다임은 컴퓨터가 사고하는 대로 프로그래밍을 하는 것이었다. 하지만 객체 지향 프로그래밍은 인간 중식점 프로그래밍 패러다임이다. 이는 현실 세계를 프로그래밍으로 옮겨오는 것을 말하는데, 현실의 사물을 객체로 보고 그 객체로부터 개발하고자 하는 특징들을 뽑아서 프로그래밍 한다. 이를 추상화라고 한다. 

OOP 장점

- 코드 중복을 피하고 재사용성이 높아짐
- 자주 사용 되는 로직을 라이브러리로 만들어 놓을 수 있다.
- 라이브러리를 각종 예외 상황에 맞게 만들어 놓으면 개발자의 실수를 최소화 할 수 있다.
- 내부 로직을 몰라도 입력과 출력에 대한 내용을 알면 개발자가 사용할 수 있기 때문에 생산성 향상에 도움이 된다.
- 객체 단위로 코드가 나누어져 작성되기 때문에 디버깅이 쉽고 유지보수가 용이하다.
- 데이터 모델링 시에 객체와 매핑하는 것이 수월하기 때문에 요구사항을 보다 명확하게 파악하며 프로그래밍이 가능하다.

OOP 단점

- 객체 간의 정보교환이 메시지 교환을 통해 일어나기 때문에 overhead가 많이 발생한다. 하지만 하드웨어의 발전으로 많이 상쇄
- 객체가 상태를 갖기 때문에 내부의 변수가 존재하고 이 변수를 통해 예측할 수 없는 상태를 가져서 오류가 날 수 도 있는데 이런 부분들의 극복을 위해 함수형 패러다임이 주목받고 있다.

<br/>
<br/>


### 객체 지향적 설계 원칙

- OCP(Open Closed Principle) : 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle) : 의존 역전 원칙

이 원칙들은 응집도는 높이고 결합도는 낮추자는 고전 원칙을 객체 지향의 관점에서 재정립한 것으로 볼 수 있다.

#### SRP = 단일 책임 원칙

어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다.

##### SRP가 안지켜진 사례

- 변수레벨
  - 하나의 속성이 여러 의미를 갖는 경우
  - 어떤 곳에서는 쓰고, 어떤 곳에선 안쓰는 속성이 있는 경우
- 메소드레벨
  - 분기처리를 위한 if문이 많을 경우

#### OCP = 개방 폐쇄 원칙
소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. 즉, 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다는 것이다. 이것은 interface 를 통해 구현하여 해결한다.

현실의 예를들면 상점직원이 아무리 바뀐다고해서 손님이 상품을 구매하는 데는 지장이 없다. 이는 직원은 판매 인터페이스를 구현해야하기 때문이다. 손님은 판매인터페이스와 소통하기 때문에 직원이 누구든 지장이 없다.

#### LSP = 리스코프 치환 원칙
서브타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다. 즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 수행하는 데 문제가 없어야 한다. 이것은 OOP 4대 특성의 상속, 인터페이스 원칙이 잘 지켜진 다면 LSP는 자동으로 잘 적용된 것이다. (주로 조직도, 계층도 관점에서의 상속이 LSP를 위배하는 문제가 생긴다)

#### ISP = 인터페이스 분리 원칙
클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다. ISP는 SRP와 비슷하지만 인터페이스를 통한 다른 해결책을 제안하고 있다. 예를들어 class 사람 implements 군인 이면 군인 홍길동 = new 사람() 을 통해 군인 인터페이스의 메소드만을 사용하도록 제한하는 것이다. SRP였다면 class를 나눠버렸겠지만.. 일반적으론 ISP보다 SRP 할 것이 권장된다.

####  DIP = 의존 역전 원칙
고차원 모듈은 저차원 모듈에 의존하면 안된다. 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다. 자주 변경되는 클래스에 의존하지 말자. 로 요약될 수 있다. 즉, 자신보다 변하기 쉬운 것에 의존하지 말라는 것이다. 해결방법은 OCP와 비슷한데, 구체적인 class가 아닌, 인터페이스에 의존함으로써 DIP를 해결한다.



설계 원칙 출처: https://sjh836.tistory.com/159 [빨간색코딩]


