<!--
author: Dailyscat
purpose: issue arrange
rules:
 (1) 헤더와 문단사이
    <br/>
    <br/>
 (2) 코드가 작성되는 부분은 >로 정리
 (3) 참조는 해당 내용 바로 아래
    <br/>
    <br/>
 (4) 명령어는 bold
 (5) 방안은 ## 안의 과정은 ###
-->

# Issue: schedulars.parallel boundedElastic 차이


- +

<br/>

## 개념: 

<br/>

Schedulers.parallel()
Schedulers.parallel()은 병렬 작업을 위한 스케줄러이고 이것은 CPU 코어 수에 비례하는 고정 크기의 스레드 풀을 사용하여 최소한의 문맥 전환(context switching)과 오버헤드로 computationally heavy(계산 집약적)한 작업들을 빠르게 수행하도록 최적화되어 있. Schedulers.parallel()은 non-blocking 연산에 적합하며, 주로 CPU 바운드 작업에 사용된다. 각 스레드는 하나의 작업만을 실행하므로, I/O 대기 시간이 없고 블로킹이 발생하지 않는 업무에 적합하다.

Schedulers.boundedElastic()
Schedulers.boundedElastic()는 특정한 최대 크기 제한(maximum pool size)이 있는 유연한 스레드 풀을 가지고 있으며 블로킹 I/O 작업을 처리할 때 사용된다. 이 스케줄러의 스레드 풀은 필요에 따라 동적으로 확장되거나 축소될 수 있고, 작업량이 많지 않을 때 스레드를 해제할 수 있기 때문에 블로킹 I/O 작업에 사용하기 좋. 블로킹 작업을 수행하는 동안 스레드가 대기 상태에서 시간을 낭비하는 대신, 해당 스레드를 다른 작업에 사용할 수 있도록 해준다.


실제 프로덕션 환경에서 Schedulers.parallel() 스케줄러는 주로 데이터 전처리, 복잡한 작업, 알고리즘 계산과 같이 스레드를 지속해서 바쁘게 할 작업에 활용된다. 반면에 Schedulers.boundedElastic()는 네트워크 호출, 디스크 입출력과 같이 스레드가 상대적으로 많은 시간 동안 대기 상태가 될 수 있는 작업에 적합하다.

예를 들어, 데이터베이스 쿼리나 원격 API 호출을 하게 되면 네트워크 지연으로 인해 스레드가 블로킹 상태가 될 수 있는데 이러한 경우 Schedulers.boundedElastic() 스케줄러를 사용하면 리액터 내부에서 스레드 풀을 관리하고 필요시 스레드의 개수를 조정하여 효율적인 리소스 사용이 가능하게 하며, 동시에 시스템의 응답성을 높일 수 있.

Schedulers.boundedElastic()은 블로킹 I/O 작업에서 높은 지연 시간이나 불확실성이 있는 네트워크 길이의 오버헤드를 고려하여 동적으로 스레드 수를 조정할 수 있도록 설계되었다. 이는 동시 요청 수가 예측하기 어려운 웹 서버와 같은 환경에서 매우 유용하다. 반면 Schedulers.parallel()은 고정된 수의 리소스(예: CPU 코어 개수)에 최적화된 작업에 더 적합하다.

리액티브 프로그래밍에서 스케줄러의 선택은 애플리케이션의 성능과 응답성에 큰 영향을 미친다. 무거운 계산 작업은 Schedulers.parallel()로, 반면 I/O 바운드 동작, 긴 지연 시간의 워크로드, 점유가 적은 작업은 Schedulers.boundedElastic()을 사용하는 것이 좋다.

parallel은 한쓰레드가 한작업을 가져가니 동기적 프로그래밍과 비슷하지 않나라고 생각했는데 그 부분은 다른것이. parallel은 병렬로 작업을 수행하기 때문에 즉, 여러 작업이 동시에 독립적으로 실행되며, 이로 인해 비동기적인 특성을 유지한다.

동기적 프로그래밍에서는 하나의 작업이 완료되기 전에는 다음 작업으로 넘어가지 않고 모든 작업은 순차적으로 이뤄지고, 한 작업이 다른 작업의 시작을 차단할 수 있. 반면, 리액티브 프로그래밍 라이브러리를 사용하여 Schedulers.parallel()로 스케줄된 작업들은 동일한 시점에 별도의 스레드(코어)에서 실행될 수 있다, 그렇기 때문에 각각의 작업은 다른 작업의 실행을 방해하지 않으며 CPU 코어를 최대한 활용한다.

MVC 웹 프레임워크를 사용하는 동기적 서버 환경에서는 클라이언트의 요청을 처리하기 위한 각 스레드가 다른 스레드의 완료를 기다릴 필요 없이 완전히 독립적으로 실행되므로, 요청 처리가 블로킹된다. 반면, Schedulers.parallel()를 사용하는 리액티브 환경에서는 비동기적으로 여러 작업을 병렬로 처리할 수 있으므로 더 적은 리소스(스레드)로 더 많은 작업을 수행할 수 있.

결론적으로, Schedulers.parallel()는 CPU 코어 수에 맞게 스레드를 고정하여 병렬 처리를 하기 위한 것이다. 또한 non-blocking 연산에 최적화되어 있지만, 이것은 동기적 프로그래밍과는 별개의 개념으로, 전체 시스템의 처리량과 응답성을 향상시키기 위한 목적으로 사용된다.

또 한가지 더 궁금했던건 boundedElastic과 parallel을 같이 사용한다는 가정을 할 때 parallel이 모든 쓰레드를 다 쓰고 있다면 boundedElastic은 작동을 못하는건가 궁금햇는데 그건 아니고 각 스케줄러는 독립된 스레드풀을 가지고 있기 때문에 각 스케줄로는 동시에 활성화될 수 있다고 한다.

parallel().runOn()

.parallel() 연산자는 Flux를 병렬 '레일'로 분리하여 여러 개의 병렬 작업 스트림으로 만든다. 이로 인해, 원래의 한 개의 스트림이 여러 개로 나뉘어 각각 별도로 작업이 수행될 수 있게 된다.
.runOn()은 바로 그 분리된 각 병렬 스트림이 실행될 스케줄러를 지정한다. Schedulers.parallel()로 지정하는 경우, 각 병렬 스트림은 순수 계산 작업(CPU-bound non-blocking work)에 최적화된 스레드 풀에서 실행된다.
parallel().runOn()은 CPU 친화적인 작업이나, 네트워크 호출이나 디스크 I/O와 같은 블로킹 작업이 없는 상황에서 더 효과적이다.

publishOn()


publishOn() 연산자는 스트림 내의 데이터 흐름(flow of data)이 특정 스케줄러에서 실행되도록 명시한다. publishOn()을 사용하면 스케줄러 전환 이후의 모든 연산이 지정된 스케줄러에서 실행된다.
publishOn()은 주로 한 개의 스트림에서만 작동하고, 작업이 비동기적으로 대기 시간이 포함된 작업인 경우, 예를 들면, 외부 서비스 호출이나 내부적으로 비동기적으로 처리가 이루어지는 작업에 적합하다.
publishOn()은 블로킹 작업에 대해서는 일반적으로 사용하지 않으며, Schedulers.parallel() 를 사용하기보다는 Schedulers.boundedElastic() 나 Schedulers.single() 같은 다른 스케줄러를 사용하는 것이 더 일반적이다.
결론적으로, parallel().runOn()과 publishOn() 모두 스트림 연산을 지정된 스케줄러로 전환하지만, 전자는 분리된 병렬 스트림에 대해, 후자는 하나의 연속된 스트림에서 특정 부분부터 스케줄러를 전환하는 경우에 사용된다. Schedulers.parallel()와 함께 사용될 때의 컨텍스트가 서로 다르다.

<br/>
<br/>
<br/>

        참조:

<br/>
