# 스트림 소개

스트림 이전에는 컬렉션을 사용하여 데이터를 그룹화하고 처리했다. 하지만 컬렉션만으로는 굉장히 많은 데이터를 처리 할 때의 성능문제가 존재하고, db의 query와 같이 선언형으로 좀 더 명확한 프로그래밍이 불가하다. 예를들어 전교 학생 만오천명의 정보가 담긴 컬렉션에서 키가 180이하인 학생 중 특정 지역에 사는 학생만을 고르는 연산이 필요한 경우가 있다. 이때 컬렉션만으로 연산을 한다면 한 번의 이터레이션에 만오천번의 읽기가 발생하는 행위를 최소 두번은 돌려야하며, 가비지 변수(특정 중간 상태를 가리키는)가 들어가면서 명료한 프로그래밍이 불가하다.

스트림은 위 두가지를 해결이 가능하다.

- 데이터셋에 선언형 프로그래밍(Select name FROM dishes WHERE calorie < 400)을 적용하여 가독성 있는 코드 작성이 가능하다.
- 데이터셋을 투명하게 병렬로 처리하는 것이 가능하다.

## 스트림이란 무엇인가?

스트림은 자바 8 api에 새로 추가된 기능이다.

스트림은 선언형으로 컬렉션 데이터를 처리할 수 있다.

스트림은 멀티스레드 코드를 구현하지 않아도 데이터에 대해 가독성있는 처리가 가능하다.

filter, sorted, map, collect 같은 연산은 고수준 빌딩 블록으로 이루어져있으므로 특정 스레딩 모델에 제한되지 않고 자유롭게 어떤 상황에서든 사용할 수 있다.

또한 이들은 내부적으로 단일 스레드 모델에 사용할 수 있지만 멀티코어 아키텍처를 최대한 투명하게 활용할 수 있게 구현되어 있다.

## 스트림 시작하기

스트림은 데이터 처리 연산을 위한 연속된 요소(sequence of element)로 정의해볼 수 있다.

- 연속된 요소: 컬렉션과 같이 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다. 컬렉션과의 차이는 컬렉션은 자료구조이므로 컬렉션에서는 시간, 공간의 복잡성과 관련하여 요소의 저장 및 접근에 대한 연산이 주를 이룬다면 스트림은 filter, sorted, map과 같은 표현 계산식이 주를 이룬다. 즉 컬렉션의 주체는 데이터이고 스트림의 주체는 계산이다.

- 소스: 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 소스로부터 데이터를 소비한다. 정렬된 컬렉션을 스트림으로 생성하면 정렬은 그대로 유지된다.

- 데이터 처리 연산: 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.(filter, map, reduce, find, match) 스트림 연산은 순차적으로 또는 병렬로 실행할 수 있다.

스트림은 두가지 중요 특징이 있다.

- 파이프라이닝: 대부분의 스트림 연산은 스트림 연산끼리 연결하여 커다란 파이프라인을 구성할 수 있도록 스트림 자산을 반환한다. 그 덕분에 Laziness, short-circuiting 과 같은 최적화가 가능하다.

- 내부 반복: 반복자를 이용하여 명시적으로 반복하는 컬렉션과 달리 스트림은 내부반복을 지원한다.


## 스트림과 컬렉션

스트림과 컬렉션은 모두 순차적으로 값에 접근할 수 있는 인터페이스를 가지고 있는 자료구조이다.

DVD에 저장되어있는 바이트와 프레임을 순차적으로 읽는걸 컬렉션이라고 생각한다면
인터넷 사이트에서 스트리밍을 통해서 읽어나가는것을 스트림이라고 예를 들 수 있다.

DVD의 경우 DVD에 존재하는 모든 데이터를 로드하여 순차적으로 데이터를 읽어나간다면,
스트리밍은 필요한 데이터를 그때 그때 받아서 데이터를 읽어나간다.

두 방식은 데이터를 언제 계산하느냐에 차이가 있다.

컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조이다. 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야한다. 컬렉션에 요소를 추가하거나 컬렉션의 요소를 삭제하는 연산이 수행될 때 마다 컬렉션의 모든 요소가 메모리에 저장되어야 하고 컬렉션에 추가하려는 요소는 미리 계산이 필요하다.

스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조로 스트림에 요소를 추가하거나, 스트림에서 요소를 제거할 수 없다. 이러한 특성은 요청 중심 제조(demand-driven manufacturing) 방식이라고 불린다.

컬렉션의 경우는 생산자 중심 제조(supplier-driven: 팔기도 전에 창고를 가득 채움) 방식으로 불린다.

### 딱 한번만 탐색이 가능하다.

컬렉션을 반복자를 통해 탐색할 때 반복자는 한번만 탐색이 가능하다.
스트림또한 한 번만 탐색이 가능하며 다시 탐색을 위해서는 초기의 데이터 소스에서 새로운 스트림을 만들어야 한다. 이때 I/O와 같은 데이터소스는 새로운 스트림을 만들 수 없다.

### 외부 반복과 내부 반복

컬렉션 인터페이스를 사용할 때는 사용자가 직접 반복자를 사용해서 요소를 반복해야한다(for-each 등) 이는 외부 반복이라고 불린다.

스트림 라이브러리는 반복을 알아서 처리하고 결과 스트림 값을 어딘가에 저장하는 내부반복을 사용한다.

내부반복은 자체적으로 병렬처리를 하여 성능적인 최적화가 가능하지만 컬렉션은 사용자의 수고가 들어가고 최적화가 힘들다.

## 스트림 연산

연결할 수 있는 연산을 중간연산(intermediate operation) 이라고 하며 스트림의 마지막에서 스트림을 닫는 연산을 최종(단말, terminal operation)연산이라고 한다.

### 중간연산(intermediate operation)

filter나 sorted 같은 중간 연산은 다른 연산을 반환하므로 여러 중간 연산을 연결하여 질의를 만들 수 있다. 중간 연산의 중요 특징은 게으르다. 게으름의 의미는 최종(단말)연산이 실행되기 전 까지는 아무 연산도 수행하지 않는다는 것을 얘기한다. 중간 연산을 합친 후 이를 최종 연산으로 한번에 처리하기 때문이다.

### 최종(단말, terminal operation)연산

최종연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종연산에 의해 List, Integer, void 등 스트림 이외의 결과가 반환된다.

### 스트림 이용하기

1. 질의를 수행할 데이터소스
2. 스트림 파이프라인을 구성할 중간 연산 연결
3. 스트림 파이프라인을 실행라고 결과를 만들 최종연산

